WARestfulHandler subclass: #RARestHandler	instanceVariableNames: 'binder'	classVariableNames: ''	poolDictionaries: ''	category: 'RestAPI'I am the REST Handler.My role is to catch rest commands and handle them.I have methods tagged with pragmas indicating which kind of REST verb they fulfill, plus a kind of regex for url matching.Then I delegate the action to a RAWrapper, and simply return what I get back.=========================accessing---------------------binder	^ binder ifNil: [ binder := RAFTPWrapper new ]binderClass	^ self class binderClassnewBinder	^ self binderClass new---------------------get------------------------------------------initialize---------------------initialize	"Initialization code for FRARestHandler"	super initialize.---------------------private---------------------convertInHtml: aGetResult	| string |		string :=  String streamContents: [ :stream | 		stream << '<html><head><meta http-equiv="content-type" content="text/html; charset=iso-8859-1"><title>Fubu</title></head><body>'.		aGetResult linesDo: [ :line | 			(line notEmpty and: [ line first == $- ])				ifTrue: [ stream << (self convertLineAsFile: line) ]				ifFalse: [ stream << (self convertLineAsDirectory: line) ] ].		stream << '</body></html>' ].	self requestContext respond: [ :response |		response		contentType: WAMimeType textHtml;		nextPutAll: string ].	"response seasideMimeDocumentType: WAMimeType textHtml.	^ response"convertInJSON: aGetResult	| result |		result := OrderedCollection new.	aGetResult linesDo: [ :line || splitted dict |		line ifNotEmpty: [			dict := Dictionary new.			result add: dict.			splitted := line splitOn: String space.			dict 				at: #permissions put: splitted first;				at: #pointers put: splitted second;				at: #owner put: splitted third;				at: #group put: splitted fourth;				at: #size put: splitted fifth;				at: #timestamp put: ((splitted copyFrom: 6 to: 8) joinUsing: ' ');				at: #name put:  ((splitted copyFrom: 9 to: splitted size) joinUsing: ' '). ] ].			self requestContext respond: [ :response |		response		contentType: WAMimeType textHtml;		nextPutAll: result asJson ].convertLineAsDirectory: aLine	^ String streamContents: [ :stream || name |		name := (aLine splitOn: String space) last.		stream << '<a href=''/api/http/directory/' << name <<'''>' << aLine << '</a></br>' ]convertLineAsFile: aLine	^ String streamContents: [ :stream || name |		name := (aLine splitOn: String space) last.		stream << '<a href=''/api/file/' << name <<'''>' << aLine << '</a></br>' ]guessTypeFor: aPath	(aPath endsWith: 'txt') ifTrue: [ ^ 'ascii' ].	^ 'binary'---------------------rest-put---------------------createNewBinaryFile: pathElement	<put>	<path:'/file/*pathElement*'>		| result path name data temporaryFile stream encryptedLogin |	pathElement ifEmpty: [ ^ 'Empty path', String crlf ].		encryptedLogin := self requestContext request headers at: #authorization ifAbsent: [ nil ].	encryptedLogin ifNotNil: [ | login |		encryptedLogin := encryptedLogin substrings last.		login := (ZnBase64Encoder new decode: encryptedLogin) asString.		login := login splitOn: ':'.		^ self createNewBinaryFile: pathElement user: login first password: login last ].		path := pathElement allButLast joinUsing:'/'.	name := pathElement last.	path ifEmpty: [ path := '.' ].	data := self requestContext request rawBody.		temporaryFile := FileSystem workingDirectory resolve: (pathElement joinUsing: '/').	temporaryFile ensureFile.	stream := temporaryFile writeStream binary.	stream nextPutAll: data asByteArray.	stream close.	[ result := self binder createNewFile: name at: path ]	on: TelnetProtocolError	do: [ :ex | result := self signalError: ex ].		temporaryFile ensureDeleted.	^ resultcreateNewBinaryFile: pathElement user: user password: password	<put>	<path:'/file/*pathElement*?user={user}&password={password}'>		| result path name data temporaryFile stream encryptedLogin loginInformation |	pathElement ifEmpty: [ ^ 'Empty path', String crlf ].		path := pathElement allButLast joinUsing:'/'.	name := pathElement last.	path ifEmpty: [ path := '.' ].	data := self requestContext request rawBody.		temporaryFile := FileSystem workingDirectory resolve: (pathElement joinUsing: '/').	temporaryFile ensureFile.	stream := temporaryFile writeStream binary.	stream nextPutAll: data asByteArray.	stream close.	loginInformation := RALoginInformation		user: user		password: password.	[ result := self binder 		loginInformation: loginInformation;		createNewFile: name at: path ]	on: TelnetProtocolError	do: [ :ex | result := self signalError: ex ].		temporaryFile ensureDeleted.	^ resultcreateNewTextFile: pathElement	<put>	"<path:'/file/*pathElement*'>	<consumes: 'text/*'>"		| result path name data temporaryFile |	pathElement ifEmpty: [ ^ 'Empty path', String crlf ].		path := pathElement allButLast joinUsing:'/'.	name := pathElement last.	path ifEmpty: [ path := '.' ].	data := self requestContext request rawBody.		temporaryFile := FileSystem workingDirectory resolve: (pathElement joinUsing: '/').	temporaryFile ensureFile.	temporaryFile writeStreamDo:[:s | s nextPutAll: data ].		[ result := self binder createNewFile: name at: path ]	on: TelnetProtocolError	do: [ :ex | result := self signalError: ex ].		temporaryFile ensureDeleted.	^ result---------------------rest-post---------------------createNewDirectory: pathElement	<post>	<path:'/directory/*pathElement*'>	| result path name context encryptedLogin |			encryptedLogin := self requestContext request headers at: #authorization ifAbsent: [ nil ].	encryptedLogin ifNotNil: [ | login |		encryptedLogin := encryptedLogin substrings last.		login := (ZnBase64Encoder new decode: encryptedLogin) asString.		login := login splitOn: ':'.		^ self createNewDirectory: pathElement user: login first password: login last ].		pathElement ifEmpty: [ ^ 'Empty path', String crlf ].		path := pathElement allButLast joinUsing:'/'.	name := pathElement last.		[ ^ self newBinder createDirectory: name at: path ]	on: TelnetProtocolError	do: [ :ex | ^ self signalError: ex ]createNewDirectory: pathElement user: user password: password	<post>	<path:'/directory/*pathElement*?user={user}&password={password}'>	| result path name loginInformation |	pathElement ifEmpty: [ ^ 'Empty path', String crlf ].		path := pathElement allButLast joinUsing:'/'.	name := pathElement last.	path ifEmpty: [ path := '.' ].		loginInformation := RALoginInformation		user: user		password: password.		[ ^ self newBinder 		loginInformation:loginInformation;		createDirectory: name at: path ]	on: TelnetProtocolError	do: [ :ex | ^ self signalError: ex ]---------------------rest-delete---------------------deleteFile: pathElement	<delete>	<path:'file/*pathElement*'>	| path type |		path := pathElement joinUsing: '/'.		[ ^ self newBinder deleteFile: path ]	on: TelnetProtocolError	do: [:ex | ^ self signalError: ex ]deleteFile: pathElement user: user password: password	<delete>	<path:'file/*pathElement*?user={user}&password={password}'>	| path loginInformation |		path := pathElement joinUsing: '/'.		 loginInformation := RALoginInformation		user: user		password: password.		[ ^ self newBinder			loginInformation: loginInformation;			deleteFile: path ]	on: TelnetProtocolError	do: [:ex | ^ self signalError: ex ]---------------------rest-get---------------------getBinaryFile: pathElement 	<get>	<path:'binary-file/*pathElement*'>	| path |		path := pathElement joinUsing: '/'.	^ self newBinder 		getFileNamed: path		type: 'binary'getBinaryFile: pathElement user: user password: password	<get>	<path:'binary-file/*pathElement*?user={user}&password={password}'>	| path loginInformation |		path := pathElement joinUsing: '/'.		loginInformation := RALoginInformation		user: user		password: password.			^ self newBinder 		loginInformation:  loginInformation;		getFileNamed: path		type: 'binary'getDirectory: pathElement	<get>	<path:'/directory/*pathElement*'>	| result path |	path := pathElement joinUsing:'/'.		path ifEmpty: [ ^ self getDirectory ].		[ result := self newBinder getDirectory: path ]	on: TelnetProtocolError	do: [:ex | result :=self signalError: ex ].		^ self convertInJSON: resultgetDirectory: pathElement user: user password: password	<get>	<path:'/directory/*pathElement*?user={user}&password={password}'>	| result path loginInformation |	path := pathElement joinUsing:'/'.	path ifEmpty: [ ^ self getDirectoryUser: user password: password ].		loginInformation := RALoginInformation		user: user		password: password.			[ result := self newBinder 		loginInformation: loginInformation;		getDirectory: path ]	on: TelnetProtocolError	do: [:ex | result := self signalError: ex ].		^ self convertInJSON: resultgetFile: pathElement	<get>	<path:'file/*pathElement*'>	| path type |		path := pathElement joinUsing: '/'.	type := self guessTypeFor: path.		[ ^ self newBinder 		getFileNamed: path		type: type ]	on: TelnetProtocolError	do: [:ex | ^ self signalError: ex ].getFile: pathElement user: user password: password	<get>	<path:'file/*pathElement*?user={user}&password={password}'>	| path type loginInformation |		path := pathElement joinUsing: '/'.	type := self guessTypeFor: path.		loginInformation := RALoginInformation		user: user		password: password.		[ ^ self newBinder 		loginInformation: loginInformation;		getFileNamed: path		type: type ]	on: TelnetProtocolError	do: [:ex | ^ self signalError: ex ].getHttpDirectory: pathElement	<get>	<path:'/http/directory/*pathElement*'>	| result path |	path := pathElement joinUsing:'/'.		path ifEmpty: [ ^ self getHttpDirectory ].		[ ^ self newBinder getDirectory: path ]	on: TelnetProtocolError	do: [:ex | ^ self signalError: ex ].	getHttpDirectory: pathElement user: user password: password	<get>	<path:'/http/directory/*pathElement*?user={user}&password={password}'>	| result path loginInformation |	path := pathElement joinUsing:'/'.	path ifEmpty: [ ^ self getDirectoryUser: user password: password ].		loginInformation := RALoginInformation		user: user		password: password.			[ result := self newBinder 		loginInformation: loginInformation;		getDirectory: path ]	on: TelnetProtocolError	do: [:ex | ^ self signalError: ex ].		^ self convertInHtml: resultgetPWD	<get>	<path:'/pwd'>		^ self newBinder getWorkingDirectory.getPWDUser:user password: password	<get>	<path:'/pwd?user={user}&password={password}'>		| loginInformation |	loginInformation := RALoginInformation		user: user		password: password.			^ self newBinder		loginInformation: loginInformation;		getWorkingDirectory.---------------------get-private---------------------getDirectory	| result |		[ result := self newBinder		getDirectory: '.' ]	on: TelnetProtocolError	do: [:ex | ^ self signalError: ex ].	^ self convertInJSON: resultgetDirectoryUser: user password: password	<get>	<path:'/directory?user={user}&password={password}'>		| result loginInformation |		 loginInformation := RALoginInformation		user: user		password: password.			[ result := self newBinder 		loginInformation: loginInformation;		getDirectory: '.'. ]	on: TelnetProtocolError	do: [ :ex | ^ self signalError: ex ].	^ self convertInJSON: resultgetHttpDirectory	| result |		[ result := self newBinder		getDirectory: '.' ]	on: TelnetProtocolError	do: [:ex | ^ self signalError: ex ].	^ self convertInHtml: resultgetHttpDirectoryUser: user password: password	<get>	<path:'/http/directory?user={user}&password={password}'>		| result loginInformation |		 loginInformation := RALoginInformation		user: user		password: password.			[ result := self newBinder 		loginInformation: loginInformation;		getDirectory: '.'. ]	on: TelnetProtocolError	do: [ :ex | ^ self signalError: ex ].	^ self convertInHtml: result---------------------error handling---------------------signalError: exception	^ exception messageText, String crlf.---------------------